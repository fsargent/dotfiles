function add-alias() {
  alias $1="$2"
  echo "alias $1='$2'" >> ~/.config/zsh/.zshrc
}


alias amend='git commit --amend'
alias pull='git pull'
alias cd="z" # Added from .zshrc (Zoxide integration)
alias ls="eza --icons=always" # Updated from .zshrc
alias la="ls -a" # Note: This will now use the updated 'ls' alias above
alias ll="ls -al" # Note: This will now use the updated 'ls' alias above
alias rb='cd ~/src/rb'
alias size="du -hs ./* | sort -hr"
alias zshedit='vim ~/.config/zsh/.zshrc'
alias reload='source ~/.config/zsh/.zshrc'
alias ga='git add'
alias gd='git diff'
alias gcm='git checkout main'
alias grhh='git reset --hard HEAD'
alias gs='git status'
alias grs='git restore'
alias grss='git restore --source'
alias grst='git restore --staged'
alias vim='nvim'
alias '??'='gh copilot suggest'
alias ka='sudo kanata -c ~/src/dotfiles/config/kanata/kanata.kbd'
alias 'gopen'='gh pr view --web'
alias helix='hx'

# Git Checkout Interactive function that works regardless of current directory's mise environment
gci() {
  # Use mise exec to run gci with the correct node environment
  # This will use the node version from your global mise config or a .tool-versions file
  mise exec node@latest -- npx git-checkout-interactive "$@"
}

# Kill process(es) running on a specific port or port range
killport() {
  if [ -z "$1" ]; then
    echo "Usage: killport <port_number|port_range>"
    echo "Examples:"
    echo "  killport 3000        # Kill process on port 3000"
    echo "  killport 3000-3015   # Kill processes on ports 3000 through 3015"
    return 1
  fi

  local input=$1
  local ports=()
  local killed_pids=()
  local total_killed=0

  # Check if input contains a range (has a dash)
  if [[ $input == *-* ]]; then
    # Parse range
    local start_port=${input%-*}
    local end_port=${input#*-}

    # Validate range
    if ! [[ "$start_port" =~ ^[0-9]+$ ]] || ! [[ "$end_port" =~ ^[0-9]+$ ]]; then
      echo "‚ùå Invalid port range format. Use: start_port-end_port (e.g., 3000-3015)"
      return 1
    fi

    if [ $start_port -gt $end_port ]; then
      echo "‚ùå Start port must be less than or equal to end port"
      return 1
    fi

    echo "üîç Scanning ports $start_port-$end_port for running processes..."

    # Generate port range
    for ((port=start_port; port<=end_port; port++)); do
      ports+=($port)
    done
  else
    # Single port
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
      echo "‚ùå Invalid port number: $input"
      return 1
    fi
    ports=($input)
  fi

  # Process each port
  for port in "${ports[@]}"; do
    local pids=$(lsof -ti :$port 2>/dev/null)

    if [ -n "$pids" ]; then
      echo "\n=== Port $port ==="
      lsof -i :$port 2>/dev/null

      echo "Killing processes on port $port: $pids"
      kill -9 $pids 2>/dev/null

      # Track killed PIDs (avoid duplicates)
      for pid in $pids; do
        if [[ ! " ${killed_pids[@]} " =~ " $pid " ]]; then
          killed_pids+=($pid)
        fi
      done

      total_killed=$((total_killed + $(echo $pids | wc -w)))
    fi
  done

  if [ $total_killed -eq 0 ]; then
    if [ ${#ports[@]} -eq 1 ]; then
      echo "No processes found running on port ${ports[0]}"
    else
      echo "No processes found running on ports $start_port-$end_port"
    fi
    return 0
  fi

  # Verify processes were killed
  sleep 1
  echo "\nüìä Summary:"
  echo "Total processes killed: $total_killed"
  echo "Unique PIDs killed: ${killed_pids[*]}"

  # Check for any remaining processes
  local remaining_count=0
  for port in "${ports[@]}"; do
    local remaining=$(lsof -ti :$port 2>/dev/null)
    if [ -n "$remaining" ]; then
      remaining_count=$((remaining_count + 1))
    fi
  done

  if [ $remaining_count -eq 0 ]; then
    echo "‚úÖ All processes successfully killed"
  else
    echo "‚ö†Ô∏è  $remaining_count port(s) may still have running processes"
  fi
}
